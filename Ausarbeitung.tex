\documentclass[onecolumn,german]{article}

\usepackage{Ausarbeitung}
\usepackage{float}
\usepackage{amsmath}

% Bitte hier Ihren Namen eintragen
\author{Sarah Barton und Sonja Vogl \\ Technische Universität München}

\title{IDP im Sommersemester 2013 \\
% Hier bitte den Titel eintragen!
       {\bf QualityControlTool}
}

% Bitte Datum des Vortrags angeben
\date{05. Juli 2013}


\begin{document}
\maketitle

%\begin{figure}
%\centerline{
%\includegraphics[width=0.9\columnwidth]{Abbildungen/TUM-Logo-102.png}
%}
%\label{tum}
%\end{figure}


\begin{abstract}
\begin{center}
\noindent
Diese Ausarbeitung soll dem Benutzer einen Einblick in die Bedienbarkeit des QualtiyControlTools geben.
Ausgehend von der ersten Version der beiden Entwickler Simon und bla werden die Erweiterungen des QualityControlTools vorgestellt.
Zudem geht diese Arbeit auf die Funktionen ein, die das QualityControlTool zur Analyse der Biosensoren GeneActive, Somnowatch, Shimmer und GT3X+  bereitstellt.
\end{center}
\end{abstract}


\newpage

\tableofcontents

\newpage
\section{Einleitung}
\label{Einleitung}

Diese Arbeit gibt dem Benutzer des QualityControlTools einen Überblick über die Möglichkeiten, die das Programm zur Analyse der Biosensoren GeneActive, Somnowatch, Shimmer und GT3X+ dem User bietet. Zudem wird dem Benutzer nahegebracht, wie das QualityControlTool zu bedienen ist. Hierzu wird zunächst die Benutzeroberfläche (siehe Kapitel \ref{v2_tool}), wie auch die Funktionsweise der einzelnen Buttons dargestellt. Zusätzlich wird grob auf die Implementierung eingegangen.


\section{Motivation}

Das Institut für Medizinische Statistik und Epidemiologie (IMSE) der TU München beschäftigt sich mit der Analyse der Daten der \textsc{Kora} Studien. \textsc{Kora} steht für die \textit{kooperative Gesundheitsforschung in der Region Augsburg}. 

Das Ziel der \textit{Feasibilty}-Studie der Nationalen Kohorten war das Testen der Realisierbarkeit mono- und multifunktioneller Apparaturen, die Körperbewegungen messen. So sollten Körperleistung (PA) und der Energieverbrauch analysiert werden. Im sepziellen wurden vier verschiedene Biosensoren betrachtet, die \textit{raw acceleration data} für mindestens 7 Tage lieferten.

Das QualityControlTool soll das Auswerten der csv-Dateien von Biosensoren erleichtern. Dafür existieren zahlreiche Algorithmen, welche in \textsc{Matlab} implementiert sind. Allerdings besitzen viele in der Medizin nur ein eingeschränktes Informatikwissen. Für diese ist eine Auswertung mit einem hohen zeitlichen und hohem Arbeitsaufwand, sich in Matlab einzuarbeiten, verbunden.

Mit dem QualityControlTool ist eine einfache Bedienbarkeit ohne informatische bzw. mathematische Kenntnisse gegeben. Sobald man mit der Benutzeroberfläche vertraut ist, übernimmt der PC das Auswerten der Daten. Zusätzlich werden die ausgewerteten Daten so gespeichert, dass sie schnell auffindbar sind und jederzeit erneut abgerufen werden können. 


\section{Ausgangslage - die erste Version des Tools}

\begin{figure}[H]
\centerline{
\includegraphics[width=0.9\columnwidth]{Abbildungen/version_1.png}
}
\caption {Gui des QualityControlTools 1. Version}
\label{v1}
\end{figure}

Die erste Version des QualityControlTools war bislang nur auf den Biosensor GT3X+ Actigraph ausgerichtet. Für diesen Sensor ließen sich csv-Dateien des Datentyps \textit{count data} auswerten. Hierzu konnte der Benutzer einen Pfad mit dem entsprechenden Dateinamen übergeben. Beim Betätigen des \textsc{Browse}-Buttons (siehe Abb.~\ref{v1}:~1) wurden die Daten der gewählten Datei geladen. Diese wurden dann als \textsc{Timeseries}-Format als \textsc{Matlab}-Datei unter dem Namen \textit{Kora1.mat} gespeichert.\newline

Für den Sensortyp und den Datentyp war bereits die Vorrichtung für eine weitere Auswahl des Benutzers vorhanden.(siehe Abb.~\ref{v1}:~2~und~3) Diese blieb aber in der ersten Version dem Benutzer gesperrt. Die Anzeige blieb auf \textit{Actigraph(gt3x,gt3x+)} sowie \textit{count/epoch measurement} gesetzt.\newline 

Zudem ermöglichte es das Tool durch das Betätigen des \textsc{Plot All Data + Cut}-Button, die eingelesenen Daten zu \textit{plotten}. Der resultierende Graph wurde unter dem Namen \textit{KoraFirstPlot.png} im Dateisystem gespeichert.\newline 

In einem nächsten Schritt konnten die gegebenen Daten zugeschnitten werden. Der Benutzer trug hierzu einen Starttag und die Anzahl der Folgetage in ein vorgegebenes Feld ein. Alle Daten, die sich nicht in diesem Zeitraum befanden, wurden weggeschnitten. Die resultierende \textsc{Timeseries} überschrieben \textit{Kora1.mat}. Aus den entstandenen Daten wurde wiederum ein Graph erstellt. Dieser wurde unter dem Namen \textit{KoraSecondPlot.png} im Dateisystem abgespeichert.\newline

Als ein so genannter Zwischenschritt war das Verändern der Epochenlänge zu sehen. Dafür musste zunächst die gewünschte Epochenlänge, als ein Vielfaches der bisherigen, eingestellt werden. (siehe Abb.~\ref{v1}:~4) Mit Hilfe von Matrizenberechnungen wurden die Werte eines Intervalls aufsummiert. Das Resultat überschreibt \textit{Kora1.mat}.\newline

Die Daten der csv-Datei ließen sich sowohl mit Hilfe von dem Algorithmus von Andre wie auch nach dem Algorithmus von Simon analysieren.
Bei dem erstgenannten wurden für jeden Tag der Eingabedaten eine bestimmte Anzahl an Werte berechnet, welche in einem Vektor gespeichert wurden. Der Vektor ließ sich anschließend in der Datei \textit{finaldata.csv} auffinden.\newline

Auch ließ sich die Tragezeit (siehe Abb.~\ref{v1}:~6) eines Sensors mit Hilfe des Algorithmus von Hecht al 98 berechnen. Resultierend geht daraus ein mit $0$ oder $1$ befüllten Vektor hervor. Dabei steht $0$ für nichtgetragen und $1$ für getragen. Aufzufinden war der Vektor sowohl als \textsc{Matlab}-Datei \textit{wearingTime.mat} und als csv-Datei \textit{wearingTime.csv} vorzufinden. 
Die csv-Datei bestand aus einer Zeitspalte sowie einer Spalte mit den errechneten Werten.\newline

Abschließend erm\"oglichte das Tool eine Auswertung der Daten nach Simon.(siehe Abb.~\ref{v1}) Es wurden pro Tag als auch für den gesamten Datensatz eine bestimmte Anzahl an Daten bestimmt. Die Ergebnisse waren in den Dateien \textit{sum\_table\_[Klassenname]} und \textit{sum\_filt\_[Klassenname]} abgelegt. Um Problemen in Java vorzubeugen, wurde am Ende das Workspace geleert.\newline

Für weiteres Interesse verweisen wir Sie auf den Praktikumsbereicht \textit{Quality Control Tool for Different Accelerometer Data} von Johannes Eder und Martin Attenkofer.




\newpage
\section{Das erweiterte Tool}
\label{v2_tool}

Bei der Erweiterung des gerade vorgestellten QualityControlTools kam es, neben den Änderungen in der Funktionalität, auch zu einigen Änderungen in der Oberfläche. Diese werden im Folgenden genauer erläutert.\newline

\begin{figure}[H]
\centerline{
\includegraphics[width=0.9\columnwidth]{Abbildungen/ErweitertesTool1.JPG}
}
\caption {Gui des QualityControlTools 2. Version}
\label{v2}
\end{figure}

In \ref{v2} sind alle Änderungen zur vorherigen Version gekennzeichnet. Dabei wird in dieser Arbeit auf die blau Markierten Felder nicht eingegangen, da diese Gegenstand einer anderen, parallel laufenden, Arbeit sind.\newline

In Feld 1 der Abbildung \ref{v2} hat sich für den Betrachter nichts geändert. Allerdings verbirgt sich hinter dem \textit{Browse}-Button eine andere Funktionalität. Statt die Datei zu laden wie in der ersten Version des Tools, wird hier nur noch die Datei ausgewählt und der entsprechende Dateipfad in die Java-Umgebung geladen. Das eigentliche Laden in die Matlab-Umgebung findet erst mit drücken des \textit{Load}-Button (siehe Abb.~\ref{v2}:~4) statt. Da die wesentlichen Änderungen des Tools darin liegen, dass mehrere Sensorarten und auch Rohdaten ausgewertet werden können musste die Funktionalität des \textit{Load}-Buttons ebenfalls erweitert werden. Die genaue Dokumentation dafür ist in Kapitel \ref{Der Load-Button} beschrieben.\newline

Wie gerade erwähnt kann das erweiterte Tool auch Rohdaten auswerten. Diese haben keine Epochenlänge in Minuten oder Sekunden wie \textit{count/epoch measurement}, sondern werden mit einer bestimmten Frequenz aufgenommen. Da nicht in allen Rohdaten diese Frequenz angegeben ist, muss der User diese wissen und per Hand eingeben. Dies ist vor Allem bei Shimmer und Somnowatch Daten nötig. Bei ActiGraph GT3X+ und GeneActive Daten wird die Frequenz automatisch ausgelesen (vgl. Kapitel \ref{Der Load-Button}). Jedoch sollte der User hier immer die Frequenz überprüfen. Damit der User also zugriff auf die Frequenz hat, diese einstellen und überprüfen kann ist die Leise Frequency (siehe Abb.~\ref{v2}:~2) hinzugekommen.\newline

In der ersten Version des Tools mussten die auszuwertenden Daten immer um 12:00 Uhr beginnen. Da die jetzigen Daten auch zu anderen Zeitpunkten anfangen können wurde das Tool um die Felder \textit{StartTime} und \textit{StartDate} erweitert (siehe Abb.~\ref{v2}:~3). Diese muss der User für Somnowatch und Shimmer Daten per Hand eingeben, da in den entsprechenden Dateien weder Informationen über Anfangszeit noch über Anfangsdatum gespeichert sind. Für Daten der anderen Sensoren werden diese Informationen automatisch eingelesen (vgl. Kapitel \ref{Der Load-Button}).\newline

Im Bereich der Buttons (siehe Abb.~\ref{v2}:~4) sind ebenfalls einige Neuerungen gemacht worden. Zum einen wurde der oben erwähnte \textit{Load}-Button hinzugefügt. Zum Anderen wurde für die Auswertung von Rohdaten der Button \textit{wearing Time van Hees} hinzugefügt (vgl. Kapitel \ref{Wearing time van Hees-Button}). Um es dem User zu ermöglichen Rohdaten in Epochdaten umzuwandeln wurde zudem der Button \textit{Raw to Counts/METs} neu angelegt (vgl. Kapitel \ref{Raw to Counts/METs-Button}).

\subsection{Der Browse-Button}\label{Der Browse-Button}
\subsubsection{Aktion des Benutzers}
Um mit dem QualityControlTool arbeiten zu können, muss zunächst der \textit{Browse}-Button betätigt werden. Im Zuge dessen muss die zu analysierende csv-Datei aus dem entsprechenden Ordner auf dem Computer des Users ausgewählt werden. 

\subsubsection{Aktionen des QualityControlTool}
Ist die auszuwertende Datei gewählt, stellt das QualityControlTool vorläufige Berechnungen an. Es wird aus der csv-Datei der Name des jeweiligen Sensors ausgelesen und in die Gui des Tools eingetragen. Anhand der Datei wird ebenfalls die Art der Daten eingetragen. Handelt es sich um Rohdaten, erscheint auf der Anzeige \textit{raw data measurement}, andernfalls \textit{count/ epoch measurement}. Zusätzlich wird die Frequenz der Sensordaten bestimmt und ebenfalls dem Benutzer dargelegt. 

\begin{figure}[H]
\centerline{
\includegraphics[width=0.9\columnwidth]{Abbildungen/Browse-Button.png}
}
\caption {Gui nach Betätigen des \textit{Browse}-Buttons}
\label{bb}
\end{figure}


\subsubsection{Beteiligte \textsc{Java}- und \textsc{Matlab}- Funktionen}

Im \textsc{Java}-Code werden in der Klasse \textit{KoraSteps} die Voreinstellungen ausgewählt. Dies findet in der Methode \textit{public static boolean precalculation(String currentPath, String currentFile, String currentDevice)} statt. Hier wird auf die entsprechenden \textsc{Matlab}-Funktionen zugegriffen. \newline

Den \textsc{Matlab}-Funktionen wird dabei der Dateipfad und der Dateiname der zuvor ausgewählten csv-Datei übergeben.
Es wird die Funktion \textit{$FindSensorName(1, file\_path)$} aufgerufen. Entsprechend des Funktionsnamens liest diese aus der Kopfzeile der Datei den Namen des behandelten Sensors. Der Name des Senors wird schließlich in \textsc{Java} auf den ermittelten Namen gesetzt und die Gui dementsprechend eingestellt. Misslingt die Suche, \textit{handelt} \textsc{Java} dies mit einem Auffangen der \textit{Exception}. Zusätzlich wird der User mit der Mitteilung ``Unknown Device Type'' benachrichtigt.\newline

Auch die Frequenz des Sensor kann mit Hilfe der \textsc{Matlab}-Funktion \textit{$FindSensorFrequency(1, file\_path)$} bestimmt werden. Auch dieses Ergebnis aktualisiert in \textsc{Java} die aktuelle \textit{Frequeny} und ist für den Benutzer auf der Gui ersichtlich gemacht.
Ein einschreitender Fehler wird wiederum mit einer \textit{Exceptionbehandlung} abgefangen und dem User mit der Nachricht ``Unknown Frequency!'' kenntlich gemacht.\newline

Erfolgreiche Vorberechnungen werden mit ``Precalculations where successful. Check allocations and press ``Load'''' bestätigt.\newline

Daneben erscheint die csv-Datei auf der dem Display der Benutzeroberfläche. Dafür ist die die Funktion \textit{private void setupCsvTable(CsvFileLoader csvFile)} in der \textsc{Java}-Klasse \textit{MainControlsBackend} zuständig.\newline

Zum Schluss wird der \textit{Load}-Button zur Nutzung freigeschalten.


\subsection{Der Load-Button}\label{Der Load-Button}
Der \textit{Load}-Button wird dem Benutzer erst nach dem Ausführen des \textit{Browse}-Vorgangs freigeschaltet.

\subsubsection{Möglichkeiten für den Benutzer}
Die Trennung des \textit{Browse}-Buttons und des \textit{Load}-Buttons erlaubt dem User vom Programm selbstsändig vorgenommene Einstellungen zu überprüfen und gegebenenfalls zu verifizieren. So lassen sich nach den Voreinstellungen sowohl der Sensorname, als auch die Frequenz und die Datenart einstellen.

\subsubsection{Programmvorgänge}
Die nun endgültigen Einstellungen werden nun erstmals in die \textsc{Matlab}-Umgebung geladen. In der \textsc{Java}-Klasse \textit{KoraSteps} wird nun die Methode \textit{KoraStep1} ausgeführt. Abhängig von dem jeweiligen Sensor und dem \textit{measurement} werden von hier aus die entsprechenden \textsc{Matlab}-Funktionen aufgerufen. Für das \textit{count/epoch measurement} existiert in diesem Tool nur eine Implementation für den Sensor Actigraph GT3X. Im Falle von falschen Usereinstellungen im Bezug auf die zugrundeliegende Datenart wird dies als Fehler behandelt. Dabei erscheint die Meldung ``No code implemented for [sensorname] count/epoch measurement!''. Das Laden im \textit{raw data measurement} ist für jeden Sensor erlaubt.\newline

Für jeden dieser Fälle existiert eine \textsc{Matlab}-Funktion. Diese weichen in Sensor- und Datentypspezifischen Details voneinander ab. Grund dafür ist beispielsweise der Unterschied im Aufbau der csv-Dateien. So besitzen die GeneActive Dateien einen Kopf mit den jeweiligen Informationen, wohingegen Somnowatch Dateien direkt mit den Daten starten. Auch die Anzahl der Spalten weichen voneinander ab.\newline

In Matlab wird in der Funktion \textit{$FileLoader\_[sensorname]Kora$} bzw. für \textit{$count/epoch measurement$} \textit{$FileLoaderKora\_new$} die Messdaten aus der csv-Datei gefiltert und zeitlich angepasst. Das Ergebnis wird unter dem \textit{$[Filename]\_RAW$} bzw. \textit{$[Filename]\_MAT$} gespeichert und für den User jederzeit wieder aufrufbar.\newline

Ist das Laden abgeschlossen, wird sowohl der \textit{PlotAllData + Cut}-Button als auch der \textit{RawToCounts/METs}-Button auf ``grün'' geschalten.

\subsection{PlotAllData + Cut -Button}
\label{Plot/Cut}

Die geladenen Daten lassen sich in einer Grafik darstellen. In der Grafik sind drei verschiedene Graphen zu sehen.(siehe Abb.~\ref{plot}) Die dazugehörige Legende beschreibt, was der jeweilige Graph darstellt. Zusätzlich ist die Grafik mit dem Sensorname, dem Datentyp und der Frequenz beschriftet. \newline

In dem Fenster des \textit{Plots} kann der Benutzer nun Einstellungen bezüglich Startzeit und Dauer der relevanten Daten treffen.\newline

\begin{figure}[H]
\centerline{
\includegraphics[width=0.7\columnwidth]{Abbildungen/Plot.png}
}
\caption {Beispiel: \textit{Plot} einer GT3X+ Datei}
\label{plot}
\end{figure}

\subsubsection{Implementierung}
Auch bei dem \textit{Plotten} wird zunächst von der \textit{KoraSteps.class} auf \textsc{Matlab} zugegriffen. Von \textit{$step2\_plotFile$} wird je nach \textit{measurement} \textit{$cutFirst1\_Raw$} bzw. \textit{$cutFirst1\_new$} aufgerufen.\newline 

Im Fall von \textit{count/epoch measurement} berechnet die Funktion lediglich ein Schaubild zur einfacheren Visualisierung der Daten, wie schon in der ersten Version des Tools. Die einzigen Änderungen zur vorherigen Version sind eine ausführlichere Titulierung des erstellten Diagramms und eine Anpassung der Beschriftung auf der x-Achse. Auf dieser sind sowohl bei \textit{count/epoch measurement} als auch bei \textit{raw data measurement} die aufgezeichnete Zeit dargestellt. Dabei wird ein Tick immer genau um 12:00 Uhr eines Tages eingezeichnet. Da die Daten im Unterschied zur ersten Version aber auch zu anderen Zeiten starten können musste hier eine zusätzliche Berechnung eingefügt werden.\newline

Bei \textit{raw data measurement} zeigt das Diagramm statt nur einer Achse alle drei gemessenen Achsen. Diese werden, neben allen anderen Berechnungen, ebenfalls in der Methode \textit{$cutFirst1\_Raw$}, abhängig von dem jeweiligen Sensortyp, beschriftet.


\subsubsection{Cut Data}
Wie oben erwähnt gibt es bei den auszuwertenden Daten verschiedene Startzeiten. Damit der User möglichst flexibel ist, was das abschneiden der irrelevanten Daten angeht wurden die zwei Felder \textit{Start Time} und \textit{Duration Hours} hinzugefügt. Neben der schon vorhandenen Funktion im nächsten Schritt nur bestimmte Tage zu plotten, können jetzt auch bestimmte Zeiten ausgewählt werden. So ist es beispielsweise möglich nur die Daten eines Tages von 6:00 Uhr bis 17:00 Uhr zu betrachten.\newline 

Ändert der Benutzer nichts an den Einstellungen der Felder \textit{Start Time} und \textit{Duration Hours} so werden die Daten jeweils vom gewünschten Tag ab 12:00 Uhr bis zum letzten, gewünschten Tag um 12:00 Uhr dargestellt. Der letzte Tag berechnet sich dabei aus dem Eintrag im Feld \textit{Start Days} plus dem Eintrag im Feld \textit{Duration Days}. Überschreitet dieser Wert den vom Sensor gemessenen Zeitraum werden alle Daten ab dem Startdatum dargestellt.\newline

Falls das Feld \textit{Duration Days} ebenfalls nicht geändert wird und somit der Eintrag auf 0 bleibt bedeutet dies, dass die auszuwertenden Daten eine Länge von 0 Tagen besitzen. Das führt in weiteren Berechnungen zu Fehlern, da kein Datensatz mehr zur Verfügung steht. Deshalb sollte der User immer darauf achten, beim beschneiden der Daten eine sinnvolle und gültige Zeitangabe zu machen.

\subsection{PlotRelevantData-Button}\label{PlotRelevantData-Button}
Der \textit{PlotRelevantData-Button} wird dem Benutzer erst nach dem Ausführen des \textit{Plots} aller Daten und Schneidevorgang zur Verfügung gestellt. Als Ausgabe erscheint die Graphik der zugeschnittenen relevanten Daten. Das Fenster entspricht dem im Kapitel \ref{Plot/Cut} vorgestellten. Allerdings lässt sich diese Graphik hier nicht weiter schneiden. Demnach lässt dieses Fenster dem Benutzer keine weiteren Angaben zur Dauer bzw. Startzeit zu.

\subsubsection{Aktionen des QualityControlTools}

/TODO!!! 

\subsection{Wearing time van Hees-Button}\label{Wearing time van Hees-Button}
Dieser Button stellt dem Benutzer eine Möglichkeit zur Berechnung der Tragezeiten bei \textit{raw data measurement} zur Verfügung. Hierbei wird der Algorithmus von van Hees (TODO: Referenz zu van Hees Doc einfügen!!!) verwendet. Der Button wird freigeschaltet sobald der Schritt \textit{PlotAllData + Cut} erfolgreich beendet wurde.

\subsubsection{Aktionen des QualityControlTool}
Sobald der User den Button gedrückt hat wird über den \textsc{Java}-Code die Methode \textit{public static boolean KoraStep5VanHees(String device, String file, int frequency)} in der Klasse \textit{KoraSteps} aufgerufen. Über diese wird dann wiederum die \textsc{Matlab}-Funktion \textit{$wearingTimevH_Raw(sensor, file, hz)$} geöffnet und berechnet. Zur Berechnung werden die Daten aus der Datei {$[Filename]\_RAW$} verwendet. Das heißt, wurden die irrelevanten Daten bereits mit der Funktion \textit{PlotRelevantData} abgeschnitten, fehlen diese auch in der \textit{wearingTime}-Berechnung. Wurde dieser Schritt (vgl. Kapitel \ref{PlotRelevantData-Button}) bisher noch nicht durchgeführt wird die Tragezeit für alle eingelesenen Daten ausgewertet. Dabei betrachtet der Algorithmus immer die eingehenden Daten in Intervallen von 15 Minuten. Aus diesem Grund müssen die auszuwertenden Daten auch eine Länge von mindestens 15 Minuten aufweisen, andernfalls wir der Fehler ''Error while performing van Hees Wearing Time calculation! Data to small!'' ausgegeben.\newline

Das Ergebnis wird auf zwei verschiedene Arten abgespeichert: Es wird eine \textit{.mat}-Datei erstellt. In dieser befindet sich eine Matrix \textit{B} die in den ersten drei Spalten die gemessenen Daten des Sensors enthält und in der vierten Spalte jeweils die Information, ob der Sensor laut van Hees getragen wurde oder nicht. Wurde der Sensor getragen ist der Eintrag gleich 1, wurde er nicht getragen ist der Eintrag gleich 0.\newline

Außerdem wird eine CSV-Datei abgespeichert. Diese enthält die genaue Zeitangabe jedes berechneten Intervalls und die dazugehörige Trage-Informationen aus der vierten Spalte der Matrix \textit{B}. Zu finden sind diese Dateien jeweils unter dem Namen {$[Filename]\_wearingTimevHees$} mit der entsprechenden Endung für den Datentyp.

\subsection{Raw to Counts/METs-Button}\label{Raw to Counts/METs-Button}

Sobald eine Datei mit dem \textit{Load}-Button (vgl. Kapitel \ref{Der Load-Button}) in die \textsc{Matlab}-Umgebung geladen wurde und es sich bei den Daten um \textit{raw data measurement} handelt besteht die Möglichkeit diese in \textit{count/epoch measurement} umzuwandeln. Diese Funktionalität stellt der Button \textit{Raw to Counts/METs} für den Benutzer zur Verfügung.\newline

Der Button wird aktiv, das heißt seine Umrandung wird grün, sobald der \textit{Load}-Vorgang erfolgreich abgeschlossen ist und solange im Feld \textit{Data type} der Typ \textit{raw data measurement} ausgewählt ist. Nachdem die Berechnungen durch diesen Button erfolgreich abgeschlossen wurden wird das Feld \textit{Data type} automatisch auf \textit{count/epoch measurement} gesetzt und alle damit verbundenen Aktionen werden freigegeben. Damit ist der \textit{Raw to Counts/METs}-Button nicht mehr aktiv, also für den User nicht mehr anwählbar.

\subsubsection{Implementierung}
Drückt der Benutzer den \textit{Raw to Counts/METs}-Button wird in der \textsc{Java}-Klasse \textit{KoraSteps} die Methode \textit{public static boolean RawDataToEpoch(String currentPath, String currentFile, String currentDevice, int currentFrequency, String startDate, String startTime)} aufgerufen. Diese öffnet sogleich die \textsc{Matlab}-Funktion \textit{$calculateCounts1(path, file, hz, sensor,d,t)$}. Da für die Berechnung der Counts die Daten nochmals direkt aus der CSV-Datei gelesen werden wird hier eine Fallunterscheidung zwischen allen Sensortypen gemacht.\newline

In jedem Fall werden zuerst die Daten aus der angegebenen Datei gelesen und in eine Matrix gespeichert. Dies geschieht jeweils mit einem Sensor-spezifischen Funktionsaufruf. Mit dieser Matrix werden in einem zweiten Schritt jeweils die Counts/METs berechnet. Diese Berechnung ist für die Sensoren GeneActive, Shimmer und Somnowatch gleich und wird in der \textsc{Matlab}-Funktion \textit{$rawDataToEpoch3(A,hz,DateTimeNum, file)$} durchgeführt. Für den Sensor ActiGraphGT3X+ muss die Berechnung angepasst werden. Deshalb wird in diesem Fall nur die Funktion \textit{$rawDataToEpoch2(path,file,hz)$} aufgerufen. Da diese Funktion also nur für den Sensor ActiGraphGT3X+ verwendet werden kann werden in ihr auch gleich die Daten aus der CSV-Datei eingelesen. Das heißt für diesen Sensor gibt es keinen extra Funktionsaufruf zum Einlesen der Daten.\newline

Bei jedem Sensor werden die Rohdaten automatisch in Counts mit einer Epochenlänge von 60 Sekunden umgewandelt. Die Ergebnisse werden dann auf zwei verschiedene Arten abgespeichert: Als erstes werden sie als timeserie unter dem Namen {$[Filename].mat$} gespeichert. Mit dieser Datei ist es dann möglich alle weiteren Berechnungen durchzuführen, die auch schon bei der ersten Version des Tools für \textit{count/epoch measurement} implementiert waren.\newline

Außerdem werden die Counts und METs in einer CSV-Datei unter dem Namen {$[Filename]\_Count\_MET.csv$} gespeichert. Diese Datei enthält dann zuerst die genaue Zeitangabe der Daten. Dahinter stehen jeweils, durch Kommata getrennt, die zugehörigen Counts und dann METs.\newline

Damit nach der erfolgreichen Umwandlung die Oberfläche auch das Richtige anzeigt wird im \textsc{Java}-Code als letzter Schritt in dieser Berechnung die Epochen-Skala aktualisiert und auf 60 Sekunden gesetzt.


\section{Beispielablauf einer Analyse von Shimmer Daten}

Im Folgenden werden die Funktionen des erweiterten Tools anhand der Auswertung einer Datei veranschaulicht. Dazu dient eine Datei des Sensors Shimmer. Es wird nicht mehr auf die genaue Implementation eingegangen, sondern lediglich alles beschrieben, was der User für die Benutzung des Tools benötigt.

\subsection{Starten des Programms}
Der Aufruf des Programms funktioniert ganz einfach über einen Doppelklick auf die Ausführbare .jar-Datei. Sollte das nicht funktionieren, kann das Programm über einen Doppelklick auf die Batch-Datei ebenfalls geöffnet werden.

Damit das Tool auf Rechner funktioniert müssen dort einige Vorinstallationen gemacht werden. Neben der Software die bereits für die erste Version des Tools benötigt wird (TODO: Verweis einfügen zu Dokumentation von Jungs), wird jetzt auch die \textsc{Matlab} TODO: Wie hieß die Matlab Erweiterung die wir noch installiert haben???

\subsection{Laden einer Shimmer Datei}

Zuerst wird über den \textit{Browse}-Button (siehe Kapitel \ref{Der Browse-Button}) auf dem Computer eine auszuwertende Datei ausgewählt. In diesem Fall handelt es sich um eine Datei mit Rohdaten von dem Sensortyp Shimmer.

\begin{figure}[H]
\centerline{
\includegraphics[width=0.9\columnwidth]{Abbildungen/Browse.jpg}
}
\caption {Nach auswählen der Datei mittels \textit{Browse}-Button}
\label{browse}
\end{figure}

Diese Informationen werden direkt aus der Datei ausgelesen und erscheinen nach den Vorberechnungen auf der Oberfläche in den jeweiligen Feldern (siehe Abbildung \ref{browse}). Somit muss der Nutzer keine Informationen über die Datei haben. Allerdings sollte trotzdem immer überprüft werden ob die Einstellungen wirklich stimmen, da es ansonsten zu Problemen oder falschen Berechnungen führen kann.

Ebenfalls wird die Frequenz automatisch gesetzt. Da diese jedoch nicht in den Daten des Sensortyps Shimmer zu finden sind wurde hier ein Defaultwert von 100 Herz angegeben. Diesen Wert gilt es für den Benutzer unbedingt zu überprüfen, da er auch abweichen kann.

Eine weitere Besonderheit die bei den beiden Sensortypen Shimmer und Somnowatch zusätzliche zu beachten sind, sind die Felder \textit{Start Date} und \textit{Start Time}. Auch diese beiden Informationen sind in den Daten der genannten Sensoren nicht enthalten. Deshalb müssen diese vor drücken des \textit{Load}-Buttons vom Benutzer unbedingt angepasst werden. Geschieht dies nicht, so wie in diesem Beispielablauf, wird jeweils der Defaultwert verwendet.

Hat der Benutzer alle Einstellungen überprüft und gegebenenfalls geändert kann nun der grün umrandete \textit{Load}-Button betätigt werden (siehe Kapitel \ref{Der Load-Button}). Wurde dieser gedrückt kann es vor Allem bei größeren Daten, abhängig von der jeweiligen Rechnerleistung, zu einer Rechenzeit von mehreren Minuten kommen.

\begin{figure}[H]
\centerline{
\includegraphics[width=0.9\columnwidth]{Abbildungen/Load.jpg}
}
\caption {Nach laden der Datei mittels \textit{Load}-Button}
\label{load}
\end{figure}

\subsection{Umwandeln von Rohdaten in Counts}

In diesem Schritt des Beispielablauf werden nun die Counts aus den Rohdaten berechnet. Natürlich besteht die Möglichkeit zuerst die Rohdaten zu Plotten (PlotAllData + Cut-Button) und zu beschneiden. Allerdings ist es für große Daten sinnvoll zuerst die Counts zu berechnen. Mit diesen dauert die Berechnung des ersten Plots nicht so lange und die Daten können auf die selbe Art beschnitten werden. In den folgenden Abschnitten wird beschrieben wie der Benutzer danach über den \textit{data type} zurück zu \textit{raw data measurement} wechseln kann um nur noch den Plot für die ausgewählten Daten durchzuführen.

Um die Rohdaten in Counts umzuwandeln muss der User lediglich den, nach dem laden grün umrandeten, Button \textit{Raw to Counts/METs} (siehe Kapitel \ref{Raw to Counts/METs-Button}) drücken. Nach der Berechnung wird in der Oberfläche die Auswahl des \textit{data type} automatisch auf \textit{count/epoch measurement} gesetzt. Nun ist es möglich zwischen beiden Einstellungen hin- und herzuspringen um Berechnungen durchzuführen die es eventuell nur für einen der Datentypen gibt. Ebenfalls wird nun die Leiste für die Einstellung der Epoche freigegeben und auf 60 Sekunden gesetzt. Gleichzeitig kann der Benutzer nun keine Änderungen mehr in der Frequenz-Leiste mehr machen (vgl. Abb. \ref{rawToCounts}).

\begin{figure}[H]
\centerline{
\includegraphics[width=0.9\columnwidth]{Abbildungen/RawToCounts.jpg}
}
\caption {Nach berechnen der Counts/METs mittels \textit{Raw to Counts/METs}-Button}
\label{rawToCounts}
\end{figure}

\subsection{Plotten aller Daten}\label{Plotten aller Daten}

Um nun die Daten auf einen wesentlichen Teil zu konzentrieren und unwichtige abzuschneiden werden in diesem Schritt erst alle Daten in einer Grafik dargestellt. Anhand dieser Grafik kann der Benutzer dann ein Zeitintervall angeben in dem die wichtigen Daten liegen. Ausschließlich die Daten in diesem Zeitintervall werden dann für weitere Berechnungen benutzt.

Zur Erstellung der Grafik für den ersten Plot wird der \textit{PlotAllData + Cut}-Button gedrückt (siehe Kapitel \ref{Plot/Cut}). Für die Beispieldaten sieht dieser wie folgt aus:

\begin{figure}[H]
\centerline{
\includegraphics[width=0.9\columnwidth]{Abbildungen/FirstPlot.jpg}
}
\caption {Erster Plot}
\label{firstPlot}
\end{figure}

Im unteren Bereich wird nun das Zeitintervall für die zukünftig verwendeten Daten angegeben. In diesem Beispiel wird der Bereich zwischen dem ersten und dem dritten Tag genutzt. Dies ergibt sich aus der \textit{1} im Feld \textit{Start Day} und der \textit{2} im Feld \textit{Duration Days}. Da die Daten in diesem Fall schon vor Ende des dritten Tages aufhören, werden in den folgenden Schritten automatisch alle Daten vom ersten Tag an bis zum Ende verwendet.

Wird vom User nun der Button \textit{PlotRelevantData} angewendet werden nur die gerade gewählten Daten in der Grafik dargestellt (siehe Abb. \ref{secondPlot}). Ab diesem Schritt werden auch für die Analyse und die Berechnung der Tragezeit nur noch die gewählten Daten verwendet.

\begin{figure}[H]
\centerline{
\includegraphics[width=0.9\columnwidth]{Abbildungen/SecondPlot.jpg}
}
\caption {Zweiter Plot}
\label{secondPlot}
\end{figure}

\subsection{Plotten der relevanten Rohdaten}

Damit die im vorherigen Schritt ausgewählten Daten für die Rohdaten genauso beschnitten werden muss der Button \textit{PlotRelevantData} gedrückt werden nachdem in dem Feld \textit{data type} der Typ \textit{raw data measurement} vom Nutzer eingestellt wurde (vgl. Abb. \ref{cut}).

\begin{figure}[H]
\centerline{
\includegraphics[width=0.9\columnwidth]{Abbildungen/Cut.jpg}
}
\caption {Ansicht der Benutzeroberfläche vor Plotten der relevanten Rohdaten}
\label{cut}
\end{figure}

Da jetzt ein Teil der Daten wegfällt funktioniert dieser Schritt schneller als der erste Plot mit Rohdaten, der wie in Kapitel \ref{Plotten aller Daten} beschrieben, umgangen wurde. Dennoch kann es auch hier zu Rechenzeiten von mehreren Minuten kommen. Sind alle Berechnungen abgeschlossen erscheint die Grafik für den zweiten Plot mit Rohdaten:

\begin{figure}[H]
\centerline{
\includegraphics[width=0.9\columnwidth]{Abbildungen/SecondPlot_RAW.jpg}
}
\caption {Zweiter Plot mit Rohdaten}
\label{secondPlot_RAW}
\end{figure}

Nun werden für folgende Anwendungen auch bei Rohdaten nur noch die gewählten, nicht mehr alle, Daten verwendet.

\subsection{Berechnung der Tragezeit nach van Hees}

TODO: Beschreibung
\begin{figure}[H]
\centerline{
\includegraphics[width=0.9\columnwidth]{Abbildungen/wearingTimevH.jpg}
}
\caption {Nach der Berechnung der Tragezeit nach van Hees}
\label{wTvH}
\end{figure}

\subsection{?}

\section{Hinweise zur Benutzung des Tools}

TODO:

- Installationen die vor der Benutzung gemacht werden müssen

- Hinweis: Keine anderen Dinge währenddessen auf dem Rechner machen (ggf. Internet ausschalten), v.a. bei großen Daten

- Besonderheiten für Shimmer, Somnowatch (z.B. Frequenz muss immer wieder neu eingestellt werden wenn zu Rohdaten zurückgewechselt wird!!!), GT3X+, GeneActiv auflisten

\end{document}

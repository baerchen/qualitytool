\documentclass[onecolumn,german]{article}

\usepackage{Ausarbeitung}
\usepackage{float}
\usepackage{amsmath}
\usepackage{tikz}


% Bitte hier Ihren Namen eintragen
\author{Sarah Barton und Sonja Vogl \\ Technische Universität München}

\title{IDP im Sommersemester 2013 \\
% Hier bitte den Titel eintragen!
       {\bf QualityControlTool}
}

% Bitte Datum des Vortrags angeben
\date{05. Juli 2013}


\begin{document}
\maketitle

%\begin{figure}
%\centerline{
%\includegraphics[width=0.9\columnwidth]{Abbildungen/TUM-Logo-102.png}
%}
%\label{tum}
%\end{figure}


\begin{abstract}
\begin{center}
\noindent

Diese Ausarbeitung gibt dem Benutzer einen Einblick in die Bedienbarkeit des QualtiyControlTools.
Ausgehend von der ersten Version der beiden Entwickler Simon und bla werden die Erweiterungen des QualityControlTools vorgestellt.
Zudem geht diese Arbeit auf die Funktionen ein, die das QualityControlTool zur Analyse der Biosensoren GeneActive, Somnowatch, Shimmer und GT3X+  bereitstellt.
\end{center}
\end{abstract}


\newpage

\tableofcontents

\newpage
\section{Einleitung}
\label{Einleitung}

Diese Arbeit gibt dem Benutzer des QualityControlTools einen Überblick über die Möglichkeiten, die das Programm zur Analyse der Biosensoren GeneActive, Somnowatch, Shimmer und GT3X+ bietet. Zudem wird dem Benutzer nahegebracht, wie das QualityControlTool zu bedienen ist. Hierzu wird zunächst die Benutzeroberfläche (siehe Kapitel \ref{v2_tool}), wie auch die Funktionsweise der einzelnen Buttons dargestellt. Zusätzlich wird grob auf die Implementierung eingegangen.

Um den Einstieg für neue Nutzer des Tools möglichst einfach zu gestalten wird in Kapitel \ref{Beispielablauf} beschrieben wie eine Auswertung einer Datei ablaufen kann. Außerdem werden in Kapitel \ref{Hinweise} einige nützliche Hinweise zur richtigen Benutzung des Tools gegeben.


\section{Motivation}

Das Institut für Medizinische Statistik und Epidemiologie (IMSE) der TU München beschäftigt sich mit der Analyse der Daten der \textsc{Kora} Studien. \textsc{Kora} steht für die \textit{kooperative Gesundheitsforschung in der Region Augsburg}. 

Das Ziel der \textit{Feasibilty}-Studie der Nationalen Kohorten war das Testen der Realisierbarkeit mono- und multifunktioneller Apparaturen, die Körperbewegungen messen. So sollten Körperleistung (PA) und der Energieverbrauch analysiert werden. Im sepziellen wurden vier verschiedene Biosensoren betrachtet, die \textit{raw acceleration data} für mindestens 7 Tage lieferten.

Das QualityControlTool soll das Auswerten der csv-Dateien von den Biosensoren erleichtern. Dafür existieren zahlreiche Algorithmen, welche in \textsc{Matlab} implementiert sind. Allerdings besitzen viele Anwender nur ein eingeschränktes Informatikwissen. Für diese ist eine Auswertung mit einem hohen zeitlichen und hohem Arbeitsaufwand, sich in Matlab einzuarbeiten, verbunden.

Mit dem QualityControlTool ist eine einfache Bedienbarkeit ohne informatische bzw. mathematische Kenntnisse gegeben. Sobald man mit der Benutzeroberfläche vertraut ist, übernimmt der PC das Auswerten der Daten. Zusätzlich werden die ausgewerteten Daten so gespeichert, dass sie schnell auffindbar sind und jederzeit erneut abgerufen werden können. 


\section{Ausgangslage - die erste Version des Tools}

\begin{figure}[H]
\centerline{
\includegraphics[width=150mm, height=95mm]{Abbildungen/version_1.png}
}
\caption {GUI des QualityControlTools 1. Version}
\label{v1}
\end{figure}

Die erste Version des QualityControlTools war bislang nur auf den Biosensor ActiGraph GT3X ausgerichtet. Für diesen Sensor ließen sich csv-Dateien des Datentyps \textit{count data} auswerten. Hierzu konnte der Benutzer einen Pfad mit dem entsprechenden Dateinamen übergeben. Beim Betätigen des \textsc{Browse}-Buttons (siehe Abb.~\ref{v1}:~1) wurden die Daten der gewählten Datei geladen. Diese wurden dann als \textsc{Timeseries}-Format als \textsc{Matlab}-Datei unter dem Namen \textit{Kora1.mat} gespeichert.\newline

Für den Sensortyp (\textit{Device}) und den Datentyp (\textit{Data type}) war bereits die Vorrichtung für eine Auswahlmöglichkeit des Benutzers vorhanden(siehe Abb.~\ref{v1}:~2~und~3). Diese blieb aber in der ersten Version dem Benutzer gesperrt. Das heißt die Anzeige war automatisch auf \textit{Actigraph(gt3x,gt3x+)} sowie auf \textit{count/epoch measurement} gesetzt und konnte nicht verändert werden.

Zudem ermöglichte es das Tool durch das Betätigen des \textit{Plot All Data + Cut}-Button, aus den eingelesenen Daten eine Grafik zu erstellen. Der, aus diesem Plot, resultierende Graph wurde unter dem Namen \textit{KoraFirstPlot.png} im Dateisystem gespeichert.

In einem nächsten Schritt konnten die gegebenen Daten zugeschnitten werden. Der Benutzer trug hierzu einen Starttag und die Anzahl der Folgetage in ein vorgegebenes Feld ein. Alle Daten, die sich nicht in diesem Zeitraum befanden, wurden weggeschnitten. Die resultierende \textsc{Timeseries} überschrieben \textit{Kora1.mat}. Aus den entstandenen Daten wurde wiederum ein Graph erstellt. Dieser wurde unter dem Namen \textit{KoraSecondPlot.png} im Dateisystem abgespeichert.\newline

Als ein so genannter Zwischenschritt war das Verändern der Epochenlänge zu sehen. Dafür musste zunächst die gewünschte Epochenlänge, als ein Vielfaches der bisherigen, eingestellt werden. (siehe Abb.~\ref{v1}:~4) Mit Hilfe von Matrizenberechnungen wurden die Werte eines Intervalls aufsummiert. Das Resultat überschreibt \textit{Kora1.mat}.\newline

Die Daten der csv-Datei ließen sich sowohl mit Hilfe von dem Algorithmus von Andre wie auch nach dem Algorithmus von Simon analysieren.
Bei dem erstgenannten wurden für jeden Tag der Eingabedaten eine bestimmte Anzahl an Werte berechnet, welche in einem Vektor gespeichert wurden. Der Vektor ließ sich anschließend in der Datei \textit{finaldata.csv} auffinden.\newline

Auch ließ sich die Tragezeit (siehe Abb.~\ref{v1}:~6) eines Sensors mit Hilfe des Algorithmus von Hecht al 98 berechnen. Resultierend geht daraus ein mit $0$ oder $1$ befüllten Vektor hervor. Dabei steht $0$ für nichtgetragen und $1$ für getragen. Aufzufinden war der Vektor sowohl als \textsc{Matlab}-Datei \textit{wearingTime.mat} und als csv-Datei \textit{wearingTime.csv} vorzufinden. Die csv-Datei bestand aus einer Zeitspalte sowie einer Spalte mit den zugehörigen, errechneten Werten.

Abschließend erm\"oglichte das Tool eine Auswertung der Daten nach Simon(siehe Abb.~\ref{v1}). Es wurden pro Tag, als auch für den gesamten Datensatz eine bestimmte Anzahl an Daten bestimmt. Die Ergebnisse waren in den Dateien \textit{sum\_table\_[Klassenname]} und \textit{sum\_filt\_[Klassenname]} abgelegt. Um Problemen in Java vorzubeugen, wurde am Ende der Workspace geleert.

Für weiteres Interesse verweisen wir Sie auf den Praktikumsbericht \textit{Quality Control Tool for Different Accelerometer Data} (TODO: Referenz einfügen) von Johannes Eder und Martin Attenkofer.




\newpage
\section{Das erweiterte Tool}
\label{v2_tool}

Bei der Erweiterung des gerade vorgestellten QualityControlTools kam es, neben den Änderungen in der Funktionalität, auch zu einigen Änderungen in der Oberfläche. Diese werden im Folgenden genauer erläutert. Im Anschluss daran folgt eine detaillierte Erklärung der dahinterstehenden Funktionalitäten und Implementierungen.

\begin{figure}[H]
\centerline{
\includegraphics[width=150mm, height=90mm]{Abbildungen/ErweitertesTool1.JPG}
}
\caption {GUI des QualityControlTools 2. Version}
\label{v2}
\end{figure}

In Abbildung \ref{v2} sind alle Änderungen zur vorherigen Version gekennzeichnet. Dabei wird in dieser Arbeit auf die blau Markierten Felder nicht eingegangen, da diese Gegenstand einer anderen, parallel laufenden, Arbeit sind.\newline

In Feld 1 der Abbildung \ref{v2} hat sich für den Betrachter nichts geändert. Allerdings verbirgt sich hinter dem \textit{Browse}-Button eine andere Funktionalität. Statt die Datei zu laden wie in der ersten Version des Tools, wird hier nur noch die Datei ausgewählt und der entsprechende Dateipfad in die \textsc{Java}-Umgebung geladen. Das eigentliche Laden in die \textsc{Matlab}-Umgebung findet erst mit drücken des \textit{Load}-Button (siehe Abb.~\ref{v2}:~4) statt. Da die wesentlichen Änderungen des Tools darin liegen, dass mehrere Sensorarten und auch Rohdaten ausgewertet werden können musste die Funktionalität des \textit{Load}-Buttons ebenfalls erweitert werden. Die genaue Dokumentation dafür ist in Kapitel \ref{Der Load-Button} beschrieben.\newline

Wie gerade erwähnt kann das erweiterte Tool auch Rohdaten auswerten. Diese haben keine Epochenlänge in Minuten oder Sekunden wie \textit{count/epoch measurement}, sondern werden mit einer bestimmten Frequenz aufgenommen. Da nicht in allen Rohdaten diese Frequenz angegeben ist, muss der User diese wissen und per Hand eingeben. Dies ist vor Allem bei Shimmer und Somnowatch Daten nötig. Bei ActiGraph GT3X+ und GeneActive Daten wird die Frequenz automatisch ausgelesen (vgl. Kapitel \ref{Der Load-Button}). Jedoch sollte der User hier immer die Frequenz überprüfen. Damit der User also zugriff auf die Frequenz hat, diese einstellen und überprüfen kann ist die Leise Frequency (siehe Abb.~\ref{v2}:~2) hinzugekommen.\newline

In der ersten Version des Tools mussten die auszuwertenden Daten immer um 12:00 Uhr beginnen. Da die jetzigen Daten auch zu anderen Zeitpunkten anfangen können wurde das Tool um die Felder \textit{StartTime} und \textit{StartDate} erweitert (siehe Abb.~\ref{v2}:~3). Diese muss der User für Somnowatch und Shimmer Daten per Hand eingeben, da in den entsprechenden Dateien weder Informationen über Anfangszeit noch über Anfangsdatum gespeichert sind. Für Daten der anderen Sensoren werden diese Informationen automatisch eingelesen (vgl. Kapitel \ref{Der Load-Button}).\newline

Im Bereich der Buttons (siehe Abb.~\ref{v2}:~4) sind ebenfalls einige Neuerungen gemacht worden. Zum einen wurde der oben erwähnte \textit{Load}-Button neu erstellt. Zum Anderen wurde für die Auswertung von Rohdaten der Button \textit{wearing Time van Hees} hinzugefügt (vgl. Kapitel \ref{Wearing time van Hees-Button}). Um es dem User zu ermöglichen Rohdaten in Epochdaten umzuwandeln wurde zudem der Button \textit{Raw to Counts/METs} neu angelegt (vgl. Kapitel \ref{Raw to Counts/METs-Button}). Im den nachstehenden Kapiteln wird nun auf die Implementierung der einzelnen Buttons näher eingegangen.

\subsection{Der Browse-Button}\label{Der Browse-Button}
\subsubsection{Aktion des Benutzers}
Um mit dem QualityControlTool arbeiten zu können, muss zunächst der \textit{Browse}-Button betätigt werden. Im Zuge dessen muss die zu analysierende csv-Datei aus dem entsprechenden Ordner auf dem Computer des Users ausgewählt werden. 

\subsubsection{Aktionen des QualityControlTool}
Ist die auszuwertende Datei gewählt, stellt das QualityControlTool vorläufige Berechnungen an. Es wird aus der csv-Datei der Name des jeweiligen Sensors ausgelesen und in die GUI des Tools eingetragen. Anhand der Datei wird ebenfalls die Art der Daten eingetragen. Handelt es sich um Rohdaten, erscheint auf der Oberfläche im Feld \textit{Data type} \textit{raw data measurement}, andernfalls \textit{count/ epoch measurement}. Zusätzlich wird die Frequenz, sofern es sich um Rohdaten handelt, der Sensordaten bestimmt und ebenfalls dem Benutzer mittels der Frequenzleiste dargelegt. In Abbildung \ref{bb} sind diese geänderten Einstellungen in der Oberfläche anhand einer Beispieldatei dargestellt.

\begin{figure}[H]
\centerline{
\includegraphics[width=160mm, height=90mm]{Abbildungen/Browse-Button.png}
}
\caption {GUI nach Betätigen des \textit{Browse}-Buttons}
\label{bb}
\end{figure}


\subsubsection{Implementierung}

Im \textsc{Java}-Code werden in der Klasse \textit{KoraSteps} die Voreinstellungen nach Aktivierung des \textit{Browse}-Button bestimmt. Dies findet in der Methode \textit{public static boolean precalculation(String currentPath, String currentFile, String currentDevice)} statt. Hier wird auf die entsprechenden \textsc{Matlab}-Funktionen zugegriffen.

Den \textsc{Matlab}-Funktionen wird dabei der Dateipfad und der Dateiname der zuvor ausgewählten csv-Datei übergeben.Es wird die Funktion \textit{$FindSensorName(1, file\_path)$} aufgerufen. Entsprechend des Funktionsnamens liest diese aus der Kopfzeile der Datei den Namen des behandelten Sensors. Die Variable für den Namen des Senors wird schließlich in \textsc{Java} auf den ermittelten Namen gesetzt und die GUI dementsprechend eingestellt. Misslingt die Suche, behandelt \textsc{Java} dies mit einem Auffangen der geworfenen Exception. Zusätzlich wird der User mit der Mitteilung ``Unknown Device Type'' benachrichtigt, was den Benutzer darauf hinweist den Sensortyp per Hand richtig einzustellen.

Die Frequenz des Sensors wird mit Hilfe der \textsc{Matlab}-Funktion \textit{$FindSensorFrequency(1, file\_path)$} bestimmt. Auch dieses Ergebnis aktualisiert in \textsc{Java} die aktuelle Variable für die Frequenz und ist für den Benutzer auf der GUI ersichtlich gemacht. Ein möglicherweise eintretender Fehler wird wiederum mit einer \textit{Exceptionbehandlung} abgefangen und dem User mit der Nachricht ``Unknown Frequency!'' kenntlich gemacht. Auch hier sollte der Benutzer diese Einstellung per Hand vornehmen.

Erfolgreiches Abschließen aller Vorberechnungen wird mit der Meldung ``Precalculations where successful. Check allocations and press ``Load'''' bestätigt.

Außerdem erscheint eine Vorschau der csv-Datei auf dem Display der Benutzeroberfläche. Dafür ist, wie auch schon in der ersten Version des Tools, die Funktion \textit{private void setupCsvTable(CsvFileLoader csvFile)} in der \textsc{Java}-Klasse \textit{MainControlsBackend} zuständig.

Zum Schluss wird der \textit{Load}-Button zur Nutzung freigeschaltet. Dies wird dem Nutzer durch eine grüne Umrandung des Buttons signalisiert.


\subsection{Der Load-Button}\label{Der Load-Button}
Der \textit{Load}-Button wird dem Benutzer nur nach dem Ausführen des \textit{Browse}-Vorgangs freigeschaltet.

\subsubsection{Möglichkeiten für den Benutzer}
Die Trennung des \textit{Browse}-Buttons und des \textit{Load}-Buttons erlaubt dem User vom Programm selbstsändig vorgenommene Einstellungen zu überprüfen und gegebenenfalls zu verifizieren. So lassen sich nach den Voreinstellungen sowohl der Sensorname, als auch die Frequenz, die Datenart und Startzeit und -datum einstellen.

\subsubsection{Implementierung}
Die endgültigen Einstellungen werden nun erstmals in die \textsc{Matlab}-Umgebung geladen. In der \textsc{Java}-Klasse \textit{KoraSteps} wird die Methode \textit{KoraStep1} ausgeführt. Abhängig von dem jeweiligen Sensor und dem \textit{measurement} werden von hier aus die entsprechenden \textsc{Matlab}-Funktionen aufgerufen. Für das \textit{count/epoch measurement} existiert in diesem Tool nur eine Implementation für den Sensor ActiGraph GT3X. Für die Sensoren Shimmer, GeneActive und ActiGraph GT3X+ gibt es hingegen lediglich eine Implementierung für \textit{raw data measurement}. Im Falle von falschen Usereinstellungen im Bezug auf die zugrundeliegende Datenart wird dies als Fehler behandelt. Dabei erscheint die Meldung ``No code implemented for [sensorname] count/epoch measurement!'' beziehungsweise ''No code implemented for ActiGraph GT3X raw data measurement''.\newline

Für jeden dieser Fälle existiert eine eigene \textsc{Matlab}-Funktion. Diese weichen in Sensor- und Datentypspezifischen Details voneinander ab. Grund dafür ist der Unterschied im Aufbau der csv-Dateien. So besitzen beispielsweise die GeneActive Dateien einen Dateikopf mit den jeweiligen Informationen wie Messfrequenz oder Startzeit, wohingegen Somnowatch Dateien direkt mit den gemessenen Beschleunigungsdaten starten. Auch die Anzahl der Spalten weichen voneinander ab.\newline

In Matlab wird in der Funktion \textit{$FileLoader\_[sensorname]Kora$} bzw. für \textit{$count/epoch measurement$} \textit{$FileLoaderKora\_new$} die Messdaten aus der csv-Datei gefiltert und zeitlich angepasst. Das Ergebnis wird unter einer Datei mit dem Namen \textit{$[Filename]\_RAW$} bzw. \textit{$[Filename]\_MAT$} gespeichert und ist so für den User jederzeit wieder aufrufbar.\newline

Ist das Laden abgeschlossen, wird sowohl der \textit{PlotAllData + Cut}-Button als auch der \textit{RawToCounts/METs}-Button grün umrandet und somit zur Benutzung freigegeben.

\subsection{PlotAllData + Cut -Button}
\label{Plot/Cut}

Die geladenen Daten lassen sich in einer Grafik darstellen. In der Grafik sind für Rohdaten drei verschiedene Graphen zu sehen.(siehe Abb.~\ref{plot}) Die dazugehörige Legende beschreibt, welche Bewegungsrichtung der jeweilige Graph darstellt. Zusätzlich ist die Grafik mit dem Sensorname, dem Datentyp, der Startzeit und der Frequenz beschriftet.

An der Darstellung des Plots für Counts hat sich nichts wesentliches im Vergleich zur ersten Version des Tools verändert. \newline

In dem Fenster des \textit{Plots} kann der Benutzer nun Einstellungen bezüglich Startzeit und Dauer der relevanten Daten treffen.\newline

\begin{figure}[H]
\centerline{
\includegraphics[width=125mm, height=100mm]{Abbildungen/Plot.png}
}
\caption {Beispiel: \textit{Plot} einer GT3X+ Datei}
\label{plot}
\end{figure}

\subsubsection{Implementierung}
Auch bei dem \textit{Plotten} wird zunächst von der \textit{KoraSteps.class} auf \textsc{Matlab} zugegriffen. Von \textit{$step2\_plotFile$} wird je nach \textit{measurement} \textit{$cutFirst1\_Raw$} bzw. \textit{$cutFirst1\_new$} aufgerufen.\newline 

Im Fall von \textit{count/epoch measurement} berechnet die Funktion lediglich ein Schaubild zur einfacheren Visualisierung der Daten, wie schon in der ersten Version des Tools. Die einzigen Änderungen zur vorherigen Version sind eine ausführlichere Titulierung des erstellten Diagramms und eine Anpassung der Beschriftung auf der x-Achse. Auf dieser sind sowohl bei \textit{count/epoch measurement} als auch bei \textit{raw data measurement} die aufgezeichnete Zeit dargestellt. Dabei wird ein Tick immer genau um 12:00 Uhr eines Tages eingezeichnet. Da die Daten im Unterschied zur ersten Version aber auch zu anderen Zeiten starten können musste hier eine zusätzliche Berechnung eingefügt werden.\newline

Bei \textit{raw data measurement} zeigt das Diagramm statt nur einer Achse alle drei gemessenen Achsen. Diese werden, neben allen anderen Berechnungen, ebenfalls in der Methode \textit{$cutFirst1\_Raw$}, abhängig von dem jeweiligen Sensortyp, beschriftet.


\subsubsection{Cut Data}
Wie oben erwähnt gibt es bei den auszuwertenden Daten verschiedene Startzeiten. Damit der User möglichst flexibel ist, was das abschneiden der irrelevanten Daten angeht wurden die zwei Felder \textit{Start Time} und \textit{Duration Hours} hinzugefügt. Neben der schon vorhandenen Funktion im nächsten Schritt nur bestimmte Tage zu plotten, können jetzt auch bestimmte Zeiten ausgewählt werden. So ist es beispielsweise möglich nur die Daten eines Tages von 6:00 Uhr bis 17:00 Uhr zu betrachten.\newline 

Ändert der Benutzer nichts an den Einstellungen der Felder \textit{Start Time} und \textit{Duration Hours} so werden die Daten jeweils vom gewünschten Tag ab 00:00 Uhr bis zum letzten, gewünschten Tag um 00:00 Uhr dargestellt. Der letzte Tag berechnet sich dabei aus dem Eintrag im Feld \textit{Start Days} plus dem Eintrag im Feld \textit{Duration Days}. Überschreitet dieser Wert den vom Sensor gemessenen Zeitraum werden alle Daten ab dem Startdatum dargestellt.\newline

Falls das Feld \textit{Duration Days} ebenfalls nicht geändert wird und somit der Eintrag auf 0 bleibt bedeutet dies, dass die auszuwertenden Daten eine Länge von 0 Tagen besitzen. Das führt in weiteren Berechnungen zu Fehlern, da kein Datensatz mehr zur Verfügung steht. Deshalb sollte der User immer darauf achten, beim beschneiden der Daten eine sinnvolle und gültige Zeitangabe zu machen.

\subsection{PlotRelevantData-Button}\label{PlotRelevantData-Button}
Der \textit{PlotRelevantData-Button} wird dem Benutzer erst nach dem Ausführen des \textit{Plots} aller Daten und dem Schneidevorgang zur Verfügung gestellt. Als Ausgabe erscheint die Grafik der zugeschnittenen, relevanten Daten. Das Fenster entspricht dem im Kapitel \ref{Plot/Cut} vorgestellten. Allerdings lässt sich diese Graphik hier nicht weiter schneiden. Demnach lässt dieses Fenster dem Benutzer keine weiteren Angaben zur Dauer bzw. Startzeit zu.

\subsubsection{Implementierung}

TODO: Umschreiben; Genauer beschreiben!!!!!
Wird der Button von dem Benutzer betätigt, wird im \textsc{Java}-Prgramm die Methode \textit{KoraStep3} der Klasse \textit{KoraSteps} aufgerufen. Von hier aus wird die \textsc{Matlab}-Funktion \textit{$step3\_cutFile$}. Für den Datentyp \textit{raw measurement} wird \textit{$cutFirstPlus2\_Raw$} benutzt. Die in der Datei \textit{[sensorname]$\_$RAW.mat} gespeicherten Daten aus dem vorangegangenen Schritt werden \textit{geplottet}. Bei \textit{count/epoch measurement} greift \textit{$step3\_cutFile$} auf \textit{$cutFirstPlus2\_new$} zu. Für diesen Datentyp werden ebenfalls die zuvor geschnittenen Daten anhand der Datei \textit{$[sensorname].mat$} gezeichnet. Der dabei enstehende \textit{Plot} wird wiederum in \textit{$[sensorname]\_SecondPlot.png$} beziehungsweise in \textit{$[sensorname]\_SecondPlot\_RAW.png$} gespeichert. Somit lässt sich die Grafik von dem User ohne erneute Einstellungen jederzeit aufrufen.

\subsection{Wearing time van Hees-Button}\label{Wearing time van Hees-Button}

Da die Berechnung der Tragezeit nach Hecht nur für Counts möglich ist wurde zusätzlich der Button \textit{Wearing time van Hees} angelegt. Dieser stellt dem Benutzer eine Möglichkeit zur Berechnung der Tragezeiten bei \textit{raw data measurement} zur Verfügung. Hierbei wird der Algorithmus von van Hees (TODO: Referenz zu van Hees Doc einfügen!!!) verwendet. Der Button wird freigeschaltet sobald der Schritt \textit{PlotAllData + Cut} erfolgreich beendet wurde.

\subsubsection{Implementierung}
Sobald der User den Button gedrückt hat wird über den \textsc{Java}-Code die Methode \textit{public static boolean KoraStep5VanHees(String device, String file, int frequency)} in der Klasse \textit{KoraSteps} aufgerufen. Über diese wird dann wiederum die \textsc{Matlab}-Funktion \textit{wearingTimevH\_Raw(sensor, file, hz)} geöffnet und berechnet. Zur Berechnung werden die Daten aus der Datei {$[Filename]\_RAW$} verwendet. Das heißt, wurden die irrelevanten Daten bereits mit der Funktion \textit{PlotRelevantData} abgeschnitten, fehlen diese auch in der \textit{wearingTime}-Berechnung. Wurde dieser Schritt (vgl. Kapitel \ref{PlotRelevantData-Button}) bisher noch nicht durchgeführt wird die Tragezeit für alle eingelesenen Daten ausgewertet. Dabei betrachtet der Algorithmus die eingehenden Daten immer in Intervallen von 15 Minuten. Aus diesem Grund müssen die auszuwertenden Daten auch eine Länge von mindestens 15 Minuten aufweisen, andernfalls wir der Fehler ''Error while performing van Hees Wearing Time calculation! Data to small!'' ausgegeben.\newline

Das Ergebnis wird auf zwei verschiedene Arten abgespeichert: Es wird eine \textit{.mat}-Datei erstellt. In dieser befindet sich eine Matrix \textit{B} die in den ersten drei Spalten die gemessenen Beschleunigungsdaten des Sensors enthält und in der vierten Spalte jeweils die Information, ob der Sensor laut van Hees getragen wurde oder nicht. Wurde der Sensor getragen ist der Eintrag gleich 1, wurde er nicht getragen ist der Eintrag gleich 0.\newline

Außerdem wird eine csv-Datei abgespeichert. Diese enthält die genaue Zeitangabe jedes berechneten Intervalls und die dazugehörige Trage-Information aus der vierten Spalte der Matrix \textit{B}. Zu finden sind diese Dateien jeweils unter dem Namen {$[Filename]\_wearingTimevHees$} mit der entsprechenden Endung für den Datentyp.

\subsection{Raw to Counts/METs-Button}\label{Raw to Counts/METs-Button}

Sobald eine Datei mit dem \textit{Load}-Button (vgl. Kapitel \ref{Der Load-Button}) in die \textsc{Matlab}-Umgebung geladen wurde und es sich bei den Daten um \textit{raw data measurement} handelt besteht die Möglichkeit diese in \textit{count/epoch measurement} umzuwandeln. Diese Funktionalität stellt der Button \textit{Raw to Counts/METs} für den Benutzer zur Verfügung.\newline

\subsubsection{Aktionen des QualityControlTool}
Der Button wird aktiv, das heißt seine Umrandung wird grün, sobald der \textit{Load}-Vorgang erfolgreich abgeschlossen ist und solange im Feld \textit{Data type} der Typ \textit{raw data measurement} ausgewählt ist. Nachdem die Berechnungen durch diesen Button erfolgreich abgeschlossen wurden wird das Feld \textit{Data type} automatisch auf \textit{count/epoch measurement} gesetzt und alle damit verbundenen Aktionen werden freigegeben. Damit ist der \textit{Raw to Counts/METs}-Button nicht mehr aktiv, also für den User nicht mehr anwählbar.

\subsubsection{Implementierung}
Drückt der Benutzer den \textit{Raw to Counts/METs}-Button wird in der \textsc{Java}-Klasse \textit{KoraSteps} die Methode \textit{public static boolean RawDataToEpoch(String currentPath, String currentFile, String currentDevice, int currentFrequency, String startDate, String startTime)} aufgerufen. Diese öffnet sogleich die \textsc{Matlab}-Funktion \textit{$calculateCounts1(path, file, hz, sensor,d,t)$}. Da für die Berechnung der Counts die Daten nochmals direkt aus der csv-Datei gelesen werden wird hier, wie auch bei dem \textit{Load}-Button (Kapitel \ref{Der Load-Button}), eine Fallunterscheidung zwischen allen Sensortypen gemacht.\newline

In jedem dieser Fälle werden zuerst die Daten aus der angegebenen Datei gelesen und in eine Matrix gespeichert. Dies geschieht jeweils mit einem Sensor-spezifischen Funktionsaufruf. Mit dieser Matrix werden in einem zweiten Schritt jeweils die Counts/METs berechnet. Diese Berechnung ist für die Sensoren GeneActive, Shimmer und Somnowatch gleich und wird in der \textsc{Matlab}-Funktion \textit{$rawDataToEpoch3(A,hz,DateTimeNum, file)$} durchgeführt. Für den Sensor ActiGraphGT3X+ muss die Berechnung angepasst werden. Deshalb wird in diesem Fall nur die Funktion \textit{$rawDataToEpoch2(path,file,hz)$} aufgerufen. Da diese Funktion also nur für den Sensor ActiGraphGT3X+ verwendet werden kann werden in ihr auch gleich die Daten aus der CSV-Datei eingelesen. Das heißt für diesen Sensor gibt es keinen extra Funktionsaufruf zum Einlesen der Daten.\newline

Bei jedem Sensor werden die Rohdaten automatisch in Counts mit einer Epochenlänge von 60 Sekunden umgewandelt. Die Ergebnisse werden dann auf zwei verschiedene Arten abgespeichert: Als erstes werden sie als timeserie unter dem Namen {$[Filename].mat$} gespeichert. Mit dieser Datei ist es dann möglich alle weiteren Berechnungen durchzuführen, die auch schon bei der ersten Version des Tools für \textit{count/epoch measurement} implementiert waren.\newline

Außerdem werden die Counts und METs in einer CSV-Datei unter dem Namen {$[Filename]\_Count\_MET.csv$} gespeichert. Diese Datei enthält dann zuerst die genaue Zeitangabe der Daten. Dahinter stehen jeweils, durch Kommata getrennt, die zugehörigen Counts und dann METs.\newline

Damit nach der erfolgreichen Umwandlung die Oberfläche auch das Richtige anzeigt wird im \textsc{Java}-Code als letzter Schritt in dieser Berechnung die Epochen-Skala aktualisiert und auf 60 Sekunden gesetzt.



\section{Abhängigkeiten im QualityControlTool}

\begin{center}
\begin{tikzpicture}
 
  \tikzstyle{level 1}=[sibling distance=60mm]
  \tikzstyle{level 2}=[sibling distance=60mm]
  \tikzstyle{level 3}=[sibling distance=45mm]
  \tikzstyle{level 3}=[sibling distance=45mm]
  
  \node {Browse}
    child  {node {Load}
      child{ node {RawToCounts/METs}}
      child{ node {PlotAllData + Cut}
        child{ node {PlotRevelantData}
         child{ node {ChangeEpoch}}
         child{ node {WearingTime (van Hees)}}
         child{ node {Analyse (Andre)}}
         child{ node {WearingTime}
          child{ node {Analyse(Simon)}}
          }
         }
      }
    };

 \end{tikzpicture}
 \end{center}

\section{Beispielablauf einer Analyse von Shimmer Daten}\label{Beispielablauf}

Im Folgenden werden die Funktionen des erweiterten Tools anhand der Auswertung einer Datei veranschaulicht. Dazu dient eine Datei des Sensors Shimmer. Es wird nicht mehr auf die genaue Implementation eingegangen, sondern lediglich alles beschrieben, was der User für die Benutzung des Tools benötigt.

\subsection{Starten des Programms}
Der Aufruf des Programms funktioniert ganz einfach über einen Doppelklick auf die Ausführbare .jar-Datei. Sollte das nicht funktionieren, kann das Programm über einen Doppelklick auf die Batch-Datei ebenfalls geöffnet werden.\newline

Damit das Tool auf dem Rechner funktioniert müssen dort einige Vorinstallationen gemacht werden. Neben der Software die bereits für die erste Version des Tools benötigt wird (TODO: Verweis einfügen zu Dokumentation von Jungs), wird jetzt auch die \textsc{Matlab} \textbf{Signal Processing Toolbox} benutzt.

\subsection{Laden einer Shimmer Datei}

Zuerst wird über den \textit{Browse}-Button (siehe Kapitel \ref{Der Browse-Button}) auf dem Computer eine auszuwertende Datei ausgewählt. In diesem Fall handelt es sich um eine Datei mit Rohdaten von dem Sensortyp Shimmer.

\begin{figure}[H]
\centerline{
\includegraphics[width=160mm, height=90mm]{Abbildungen/Browse.JPG}
}
\caption {Nach auswählen der Datei mittels \textit{Browse}-Button}
\label{browse}
\end{figure}

Diese Informationen werden direkt aus der Datei ausgelesen und erscheinen nach den Vorberechnungen auf der Oberfläche in den jeweiligen Feldern (siehe Abbildung \ref{browse}). Somit muss der Nutzer keine Informationen über die Datei haben. Allerdings sollte trotzdem immer überprüft werden ob die Einstellungen wirklich stimmen, da es ansonsten zu Problemen oder falschen Berechnungen führen kann.\newline

Ebenfalls wird die Frequenz automatisch gesetzt. Da diese jedoch nicht in den Daten des Sensortyps Shimmer zu finden sind wurde hier ein Defaultwert von 100 Herz angegeben. Diesen Wert gilt es für den Benutzer unbedingt zu überprüfen, da er auch abweichen kann.\newline

Eine weitere Besonderheit die bei den beiden Sensortypen Shimmer und Somnowatch zusätzliche zu beachten sind, sind die Felder \textit{Start Date} und \textit{Start Time}. Auch diese beiden Informationen sind in den Daten der genannten Sensoren nicht enthalten. Deshalb müssen diese vor drücken des \textit{Load}-Buttons vom Benutzer unbedingt angepasst werden. Geschieht dies nicht, so wie in diesem Beispielablauf, wird jeweils der voreingestellte Defaultwert verwendet.\newline

Hat der Benutzer alle Einstellungen überprüft und gegebenenfalls geändert kann nun der grün umrandete \textit{Load}-Button betätigt werden (siehe Kapitel \ref{Der Load-Button}). Wurde dieser gedrückt kann es vor Allem bei größeren Daten, abhängig von der jeweiligen Rechnerleistung, zu einer Rechenzeit von mehreren Minuten kommen.

\begin{figure}[H]
\centerline{
\includegraphics[width=160mm, height=90mm]{Abbildungen/Load.JPG}
}
\caption {Nach laden der Datei mittels \textit{Load}-Button}
\label{load}
\end{figure}

\subsection{Umwandeln von Rohdaten in Counts}

In diesem Schritt des Beispielablauf werden nun die Counts aus den Rohdaten berechnet. Natürlich besteht die Möglichkeit zuerst die Rohdaten zu Plotten (PlotAllData + Cut-Button) und zu beschneiden. Allerdings ist es für große Daten sinnvoll zuerst die Counts zu berechnen. Mit diesen dauert die Berechnung des ersten Plots nicht so lange und die Daten können auf die selbe Art beschnitten werden. In den folgenden Abschnitten wird beschrieben wie der Benutzer danach über den \textit{Data type} zurück zu \textit{raw data measurement} wechseln kann um nur noch den Plot für die ausgewählten Rohdaten durchzuführen.\newline

Um die Rohdaten in Counts umzuwandeln muss der User lediglich den, nach dem Laden grün umrandeten, Button \textit{Raw to Counts/METs} (siehe Kapitel \ref{Raw to Counts/METs-Button}) drücken. Nach der Berechnung wird in der Oberfläche die Auswahl des \textit{Data type} automatisch auf \textit{count/epoch measurement} gesetzt. Nun ist es möglich zwischen beiden Einstellungen hin- und herzuspringen um Berechnungen durchzuführen die es eventuell nur für einen der Datentypen gibt.\newline

Ebenfalls wird nun die Leiste für die Einstellung der Epoche freigegeben und auf 60 Sekunden gesetzt. Gleichzeitig kann der Benutzer nun keine Änderungen mehr in der Frequenz-Leiste mehr machen (vgl. Abb. \ref{rawToCounts}).\newline

\begin{figure}[H]
\centerline{
\includegraphics[width=160mm, height=90mm]{Abbildungen/RawToCounts.JPG}
}
\caption {Nach berechnen der Counts/METs mittels \textit{Raw to Counts/METs}-Button}
\label{rawToCounts}
\end{figure}

\subsection{Plotten aller Daten}\label{Plotten aller Daten}

Um nun die Daten auf einen wesentlichen Teil zu konzentrieren und unwichtige abzuschneiden werden in diesem Schritt erst alle Daten in einer Grafik dargestellt. Anhand dieser Grafik kann der Benutzer dann ein Zeitintervall angeben in dem die wichtigen Daten liegen. Ausschließlich die Daten in diesem Zeitintervall werden dann für weitere Berechnungen benutzt.\newline

Zur Erstellung der Grafik für den ersten Plot wird der \textit{$PlotAllData + Cut$}-Button gedrückt (siehe Kapitel \ref{Plot/Cut}). Für die Beispieldaten sieht dieser wie folgt aus:

\begin{figure}[H]
\centerline{
\includegraphics[width=125mm, height=100mm]{Abbildungen/FirstPlot.JPG}
}
\caption {Erster Plot}
\label{firstPlot}
\end{figure}

Im unteren Bereich wird nun das Zeitintervall für die zukünftig verwendeten Daten angegeben. In diesem Beispiel wird der Bereich zwischen dem ersten und dem dritten Tag genutzt. Dies ergibt sich aus der \textit{1} im Feld \textit{Start Day} und der \textit{2} im Feld \textit{Duration Days}. Da die Daten in diesem Fall schon vor Ende des dritten Tages aufhören, werden in den folgenden Schritten automatisch alle Daten vom ersten Tag an bis zum Ende verwendet.\newline

Wird vom User nun der Button \textit{PlotRelevantData} angewendet werden nur die gerade gewählten Daten in der Grafik dargestellt (siehe Abb. \ref{secondPlot}). Ab diesem Schritt werden auch für die Analyse und die Berechnung der Tragezeit nur noch die gewählten Daten verwendet.

\begin{figure}[H]
\centerline{
\includegraphics[width=125mm, height=100mm]{Abbildungen/SecondPlot.JPG}
}
\caption {Zweiter Plot}
\label{secondPlot}
\end{figure}

\subsection{Plotten der relevanten Rohdaten}

Damit die im vorherigen Schritt ausgewählten Daten für die Rohdaten genauso beschnitten werden muss der Button \textit{PlotRelevantData} gedrückt werden nachdem in dem Feld \textit{Data type} der Typ \textit{raw data measurement} vom Nutzer eingestellt wurde (vgl. Abb. \ref{cut}).

\begin{figure}[H]
\centerline{
\includegraphics[width=160mm, height=90mm]{Abbildungen/Cut.JPG}
}
\caption {Ansicht der Benutzeroberfläche vor Plotten der relevanten Rohdaten}
\label{cut}
\end{figure}

Da jetzt ein Teil der Daten wegfällt funktioniert dieser Schritt schneller als der erste Plot mit Rohdaten, der wie in Kapitel \ref{Plotten aller Daten} beschrieben, umgangen wurde. Dennoch kann es auch hier zu Rechenzeiten von mehreren Minuten kommen. Sind alle Berechnungen abgeschlossen erscheint die Grafik für den zweiten Plot mit Rohdaten:

\begin{figure}[H]
\centerline{
\includegraphics[width=125mm, height=100mm]{Abbildungen/SecondPlot_RAW.JPG}
}
\caption {Zweiter Plot mit Rohdaten}
\label{secondPlot_RAW}
\end{figure}

Nun werden für folgende Anwendungen auch bei Rohdaten nur noch die gewählten, nicht mehr alle, Daten verwendet.

\subsection{Berechnung der Tragezeit nach van Hees}

TODO: Beschreibung
\begin{figure}[H]
\centerline{
\includegraphics[width=160mm, height=90mm]{Abbildungen/wearingTimevH.JPG}
}
\caption {Nach der Berechnung der Tragezeit nach van Hees}
\label{wTvH}
\end{figure}

\subsection{}

\section{Hinweise zur Benutzung des Tools}\label{Hinweise}

/TODO:

- Installationen die vor der Benutzung gemacht werden müssen

- Hinweis: Keine anderen Dinge währenddessen auf dem Rechner machen (ggf. Internet ausschalten), v.a. bei großen Daten

- Besonderheiten für Shimmer, Somnowatch (z.B. Frequenz muss immer wieder neu eingestellt werden wenn zu Rohdaten zurückgewechselt wird!!!), GT3X+, GeneActiv auflisten




\end{document}


